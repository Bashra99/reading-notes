# [Django Settings Best Practices](https://djangostars.com/blog/configuring-django-settings-best-practices/)
 **Managing Django Settings: Issues**

* Different environments. Usually, you have several environments: local, dev, ci, qa, staging, production, etc.
* Each environment can have its own specific settings (for example: DEBUG = True, more verbose logging, additional apps, some mocked data, etc).
* You need an approach that allows you to keep all these Django setting configurations.

* **Sensitive data**
  * You have SECRET_KEY in each Django project.
  * On top of this there can be DB passwords and tokens for third-party APIs like Amazon or Twitter.
  * This data cannot be stored in VCS.

* **Sharing settings between team members**
  * You need a general approach to eliminate human error when working with the settings.
  * For example, a developer may add a third-party app or some API (Links to an external site.) integration and fail to add specific settings.
  * On large (or even mid-size) projects, this can cause real issues.

* **Django settings are a Python code**
  * This is a curse and a blessing at the same time.
  * It gives you a lot of flexibility, but can also be a problem – instead of key-value pairs, settings.py can have a very tricky logic.

**Setting Configuration: Different Approaches**

* There is no built-in universal way to configure Django settings without hardcoding them.
* But books, open-source and work projects provide a lot of recommendations and approaches on how to do it best.
* Let’s take a brief look at the most popular ones to examine their weaknesses and strengths.

 **settings_local.py**

* This is the oldest method. I used it when I was configuring a Django project on a production server for the first time.
* I saw a lot of people use it back in the day, and I still see it now.

# [SSH Tutorial](https://www.hostinger.com/tutorials/ssh-tutorial-how-does-ssh-work)

* SSH is Secure Shell Protocol
* allows user to do stuff to their remote server over internet
* authenticates a remote user, transfers iputs from client to host and relays the output back to client
* ssh {user}@{host}
* host is the computer you want to access (ip)
* user is the user targeted
* symmetrical encryption, asymmetrical encryption, and hashing
* symmetrical encryption
  * also called shared key or shared secret encryption
  * uses a secret key to encrypt and decrypt
  * anyone with key can do these things
  * key is generated by key exchange algorithm and the key is never sent from client to host or vica verca
  * key is never disclosed to third party
  * send part of key and algorithm finds it
  * token is created new every session
* asymmetric encryption
  * encryption and decryption are automatic
  * anyone can encrypts with public key
  * public-private key pair
  * asymmetrical then symmetrical
  * used during key exchange algorithm of symmetric encryption
* Hashing
  * never meant to be decrypted
  * practically impossible to reverse
  * can compare hashes to see if they match
  * message authentication
* client and host connect over port 22
* steps to establish connection: both systems must agree on encryption standard to protect future come, user must authenticate themselves
* session encryption negotiation
  * both client and host arrive at an encryption key with algorithm

## Bookmark

* [White Noise](http://whitenoise.evans.io/en/stable/)
* [IaaS](https://en.wikipedia.org/wiki/Infrastructure_as_a_service)
* [PaaS](https://en.wikipedia.org/wiki/Platform_as_a_service)
* [CORS](https://en.m.wikipedia.org/wiki/Cross-origin_resource_sharing)
